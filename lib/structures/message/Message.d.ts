import { MessageAttachment } from './MessageAttachment';
import { MessageEmbed, MessageEmbedOptions } from './MessageEmbed';
import { MessageMentions } from './MessageMentions';
import Collection from '../../Collection';
import { RequestFile } from '../../api/rateLimit';
import { Bot } from '../../bot';
import { MessageReactionsController } from '../../controllers/message';
import { Snowflake } from '../../types';
import { EmojiResolvable } from '../Emoji';
import { Timestamp } from '../Timestamp';
import { User } from '../User';
import { BaseStruct, GatewayStruct } from '../base';
import { TextBasedChannel } from '../channels';
import { MessageFlags } from '../flags';
import { Guild } from '../guild';
import { Member } from '../member/Member';
/**
 * The type of a message
 */
declare enum MessageType {
    Default = 0,
    RecipientAdd = 1,
    RecipientRemove = 2,
    Call = 3,
    ChannelNameChange = 4,
    ChannelIconChange = 5,
    ChannelPinnedMessage = 6,
    GuildMemberJoin = 7,
    UserPremiumGuildSubscription = 8,
    UserPremiumGuildSubscriptionTier1 = 9,
    UserPremiumGuildSubscriptionTier2 = 10,
    UserPremiumGuildSubscriptionTier3 = 11,
    ChannelFollowAdd = 12,
    GuildDiscoveryDisqualified = 13,
    GuildDiscoveryRequalified = 14
}
export interface PartialMessage {
    id: Snowflake;
    guild?: Guild;
    channel: TextBasedChannel;
}
/**
 * Message activity types
 */
export declare enum MessageActivityType {
    Join = 1,
    Spectate = 2,
    Listen = 3,
    JoinRequest = 4
}
/**
 * Information about the message activity
 */
export interface MessageActivity {
    /**
     * The type of the message activity
     */
    type: MessageActivityType;
    /**
     * The party_id from a Rich Presence event
     * https://discord.com/developers/docs/rich-presence/how-to#updating-presence-update-presence-payload-fields
     */
    partyId?: string;
}
/**
 * Information about the message application
 */
export interface MessageApplication {
    /**
     * The ID of the application
     */
    id: Snowflake;
    /**
     * The ID of the embed's image asset
     */
    coverImage?: string;
    /**
     * The application's description
     */
    description: string;
    /**
     * The ID of the application's icon
     */
    icon: string | null;
    /**
     * The name of the application
     */
    name: string;
}
/**
 * Information about the message reference for crossposted messages
 */
export interface MessageReference {
    /**
     * ID of the originating message
     */
    messageId?: Snowflake;
    /**
     * ID of the originating message's channel
     */
    channelId: Snowflake;
    /**
     * ID of the originating message's guild
     */
    guildId?: Snowflake;
}
/**
 * The message data for when sending new messages
 */
export interface MessageData {
    /**
     * The message's raw content
     */
    content?: string;
    /**
     * The message's embed data
     */
    embed?: Omit<MessageEmbedOptions, 'type' | 'provider' | 'video'> | MessageEmbed;
    /**
     * The path to a file to send as an attachment
     */
    files?: RequestFile[];
}
/**
 * The message options for when sending a new message
 */
export interface MessageOptions {
    /**
     * A nonce that can be used for identifying the sent message
     */
    nonce?: number | string;
    /**
     * Whether this is a Text To Speech (TTS) message
     */
    tts?: boolean;
}
/**
 * The message data for when editing a message
 */
export interface MessageEditData extends MessageData {
    /**
     * The new flags of the message
     */
    flags?: MessageFlags;
}
/**
 * Represents a message sent in a {@link TextChannel} within Discord
 */
export declare class Message extends BaseStruct {
    /**
     * The message's ID
     */
    id: Snowflake;
    /**
     * The guild the message was sent in. Possibly null if message was sent over a DM
     */
    guild: Guild | undefined;
    /**
     * The channel the message was sent in
     */
    channel: TextBasedChannel;
    /**
     * The author of this message.
     * Might not be a valid {@link User} object if message was generated by a webhook
     */
    author: User | undefined;
    /**
     * The member properties for this message's author.
     * Might not exist if message was sent over a DM
     */
    member: Member | undefined;
    /**
     * The content of the message
     */
    content: string;
    /**
     * Timestamp of when this message was sent
     */
    sentAt: Timestamp;
    /**
     * Timestamp of when this message was edited.
     * Possibly null if message has not been edited
     */
    editedAt: Timestamp | null;
    /**
     * Whether this was a TTS message
     */
    tts: boolean;
    /**
     * Whether this message mentions everyone
     */
    mentionsEveryone: boolean;
    /**
     * All types of mentionable instances mentioned in this message
     */
    mentions: MessageMentions;
    /**
     * {@link Collection} of all {@link MessageAttachment}s attached to this message
     */
    attachments: Collection<Snowflake, MessageAttachment>;
    /**
     * All embedded content associated to this message
     */
    embeds: MessageEmbed[];
    /**
     * The message's reactions controller
     */
    reactions: MessageReactionsController;
    /**
     * Used for validating a message was sent
     */
    nonce: number | string | undefined;
    /**
     * Whether this message is pinned
     */
    pinned: boolean;
    /**
     * The Webhook ID in case this message was generated by a Webhook
     */
    webhookId: Snowflake | undefined;
    /**
     * The type of the message
     */
    type: MessageType;
    /**
     * Sent with Rich Presence-related chat embeds
     */
    activity: MessageActivity | undefined;
    /**
     * Sent with Rich Presence-related chat embeds
     */
    application: MessageApplication | undefined;
    /**
     * Reference data sent with crossposted messages
     */
    messageReference: MessageReference | undefined;
    /**
     * Describes extra features of the message
     */
    flags: MessageFlags | undefined;
    /**
     * Whether this message is deleted from its channel
     */
    deleted: boolean;
    constructor(bot: Bot, message: GatewayStruct, channel: TextBasedChannel);
    /**
     * @ignore
     * @param {GatewayStruct} message The message data
     * @returns {this}
     */
    init(message: GatewayStruct): this;
    /**
     * Creates a reaction for this message.
     * Requires the {@link Permission.ReadMessageHistory} permission.
     * Additionally, if nobody else has reacted to the message using this emoji, this requires the {@link Permission.AddReactions} permission
     * @param {EmojiResolvable} emoji The emoji to react to this message with
     * @returns {Promise<void>}
     */
    react(emoji: EmojiResolvable): Promise<void>;
    /**
     * Edits a previously sent message.
     * The fields `content`, `embed` and `flags` can be edited by the original message author. Other users can only edit `flags` and only if they have the {@link Permission.ManageMessages} permission in the corresponding channel.
     * @param {string | MessageEditData} data The updated message data.
     * Can be:
     * 1. Raw content to be edited to
     * @example ```typescript
     * message.edit('Updated content!');
     * ```
     * 2. A {@link MessageEditData} object, containing any of the fields
     * @example ```typescript
     * message.edit({ content: 'Updated content!', embed: { title: 'My Embed!' } });
     * ```
     * @returns {Promise<Message>}
     */
    edit(data: string | MessageEditData): Promise<Message>;
    /**
     * Deletes a message.
     * If operating on a {@link GuildChannel} and trying to delete a message that was not sent by the current user, this endpoint requires the {@link Permission.ManageMessages} permission
     * @returns {Promise<void>}
     */
    delete(): Promise<void>;
    /**
     * Pins this message.
     * Requires the {@link Permission.ManageMessages} permission
     * @returns {Promise<void>}
     */
    pin(): Promise<void>;
    /**
     * Unpins this message.
     * Requires the {@link Permission.ManageMessages} permission
     * @returns {Promise<void>}
     */
    unpin(): Promise<void>;
}
export {};
